[H[2J[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building vasco 1.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
Downloading: https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/heros/heros/1.0.0-SNAPSHOT/maven-metadata.xml
[WARNING] Could not transfer metadata heros:heros:1.0.0-SNAPSHOT/maven-metadata.xml from/to soot-release (https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/): Failed to transfer file: https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/heros/heros/1.0.0-SNAPSHOT/maven-metadata.xml. Return code is: 400 , ReasonPhrase:Repository version policy: RELEASE does not allow metadata in path: heros/heros/1.0.0-SNAPSHOT/maven-metadata.xml.
Downloading: https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/ca/mcgill/sable/jasmin/3.0.0-SNAPSHOT/maven-metadata.xml
[WARNING] Could not transfer metadata ca.mcgill.sable:jasmin:3.0.0-SNAPSHOT/maven-metadata.xml from/to soot-release (https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/): Failed to transfer file: https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/ca/mcgill/sable/jasmin/3.0.0-SNAPSHOT/maven-metadata.xml. Return code is: 400 , ReasonPhrase:Repository version policy: RELEASE does not allow metadata in path: ca/mcgill/sable/jasmin/3.0.0-SNAPSHOT/maven-metadata.xml.
Downloading: https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/pxb/android/axml/2.0.0-SNAPSHOT/maven-metadata.xml
[WARNING] Could not transfer metadata pxb.android:axml:2.0.0-SNAPSHOT/maven-metadata.xml from/to soot-release (https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/): Failed to transfer file: https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/pxb/android/axml/2.0.0-SNAPSHOT/maven-metadata.xml. Return code is: 400 , ReasonPhrase:Repository version policy: RELEASE does not allow metadata in path: pxb/android/axml/2.0.0-SNAPSHOT/maven-metadata.xml.
[INFO] 
[INFO] --- exec-maven-plugin:1.6.0:java (default-cli) @ vasco ---
Soot started on Wed May 29 02:39:12 IST 2019
[Call Graph] For information on where the call graph may be incomplete, use the verbose option to the cg phase.
[Spark] Pointer Assignment Graph in 0.1 seconds.
[Spark] Type masks in 0.0 seconds.
[Spark] Pointer Graph simplified in 0.0 seconds.
[Spark] Propagation in 0.0 seconds.
[Spark] Solution found in 0.0 seconds.
Setting value before args := @parameter0: java.lang.String[]
Setting value after args := @parameter0: java.lang.String[]
Setting value before i = 2
Setting value after i = 2
Setting value before $r0 = new vasco.tests.A
Setting value after $r0 = new vasco.tests.A
Setting value before specialinvoke $r0.<vasco.tests.A: void <init>()>()
Setting value after specialinvoke $r0.<vasco.tests.A: void <init>()>()
Setting value before a = $r0
Setting value after a = $r0
Setting value before $r1 = new vasco.tests.B
Setting value after $r1 = new vasco.tests.B
Setting value before specialinvoke $r1.<vasco.tests.B: void <init>()>()
Setting value after specialinvoke $r1.<vasco.tests.B: void <init>()>()
Setting value before b = $r1
Setting value after b = $r1
Setting value before $r2 = new vasco.tests.C
Setting value after $r2 = new vasco.tests.C
Setting value before specialinvoke $r2.<vasco.tests.C: void <init>()>()
Setting value after specialinvoke $r2.<vasco.tests.C: void <init>()>()
Setting value before c = $r2
Setting value after c = $r2
Setting value before if i <= 0 goto a = c
Setting value after if i <= 0 goto a = c
Setting value before a = b
Setting value after a = b
Setting value before goto [?= i#4 = 0]
Setting value after goto [?= i#4 = 0]
Setting value before a = c
Setting value after a = c
Setting value before i#4 = 0
Setting value after i#4 = 0
Setting value before virtualinvoke a.<vasco.tests.A: void m()>()
Setting value after virtualinvoke a.<vasco.tests.A: void m()>()
Setting value before return
Setting value after return
Setting value before args := @parameter0: java.lang.String[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : args := @parameter0: java.lang.String[]~~~~~~~~~~~~~~~~~~~~~~~~~~~
IN = []
Inside NormalFLowFunction : 
IN = []
IN : = []
OUT = []
Setting value after args := @parameter0: java.lang.String[]
OUT after merge= []
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[]
Node b = $r1 : InValue =[]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[]
Node b = $r1 : OutValue =[]
Node $r0 = new vasco.tests.A : OutValue =[]
Node a = $r0 : OutValue =[]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : i = 2~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of i = 2
predecessor = args := @parameter0: java.lang.String[]
predOut = []
Setting value before i = 2
IN = []
Inside NormalFLowFunction : 
IN = []
IN : = []
OUT = []
Setting value after i = 2
OUT after merge= []
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[]
Node b = $r1 : InValue =[]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[]
Node b = $r1 : OutValue =[]
Node $r0 = new vasco.tests.A : OutValue =[]
Node a = $r0 : OutValue =[]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : $r0 = new vasco.tests.A~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of $r0 = new vasco.tests.A
predecessor = i = 2
predOut = []
Setting value before $r0 = new vasco.tests.A
IN = []
Inside NormalFLowFunction : 
IN = []
IN : = []
OUT = [{$r0=vasco.tests.A}]
Setting value after $r0 = new vasco.tests.A
OUT after merge= [{$r0=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[]
Node b = $r1 : InValue =[]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[]
Node b = $r1 : OutValue =[]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke $r0.<vasco.tests.A: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke $r0.<vasco.tests.A: void <init>()>()
predecessor = $r0 = new vasco.tests.A
predOut = [{$r0=vasco.tests.A}]
Setting value before specialinvoke $r0.<vasco.tests.A: void <init>()>()
IN = [{$r0=vasco.tests.A}]
Setting value before this := @this: vasco.tests.A
Setting value after this := @this: vasco.tests.A
Setting value before specialinvoke this.<java.lang.Object: void <init>()>()
Setting value after specialinvoke this.<java.lang.Object: void <init>()>()
Setting value before return
Setting value after return
Setting value before this := @this: vasco.tests.A
[NEW] X1 -> X2 <vasco.tests.A: void <init>()> 
ENTRY(X2) = [{this=vasco.tests.A}]
IN = [{$r0=vasco.tests.A}]
IN : = [{$r0=vasco.tests.A}]
OUT = [{$r0=vasco.tests.A}]
Setting value after specialinvoke $r0.<vasco.tests.A: void <init>()>()
OUT after merge= [{$r0=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[]
Node b = $r1 : InValue =[]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[]
Node b = $r1 : OutValue =[]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : this := @this: vasco.tests.A~~~~~~~~~~~~~~~~~~~~~~~~~~~
IN = [{this=vasco.tests.A}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.A}]
IN : = [{this=vasco.tests.A}]
OUT = [{this=vasco.tests.A}]
Setting value after this := @this: vasco.tests.A
OUT after merge= [{this=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[]
Node return : InValue =[]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.A}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[]
Node return : OutValue =[]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.A}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke this.<java.lang.Object: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke this.<java.lang.Object: void <init>()>()
predecessor = this := @this: vasco.tests.A
predOut = [{this=vasco.tests.A}]
Setting value before specialinvoke this.<java.lang.Object: void <init>()>()
IN = [{this=vasco.tests.A}]
Setting value before l0 := @this: java.lang.Object
Setting value after l0 := @this: java.lang.Object
Setting value before return
Setting value after return
Setting value before l0 := @this: java.lang.Object
[NEW] X2 -> X3 <java.lang.Object: void <init>()> 
ENTRY(X3) = [{l0=vasco.tests.A}]
IN = [{this=vasco.tests.A}]
IN : = [{this=vasco.tests.A}]
OUT = [{this=vasco.tests.A}]
Setting value after specialinvoke this.<java.lang.Object: void <init>()>()
OUT after merge= [{this=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[{this=vasco.tests.A}]
Node return : InValue =[]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.A}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[{this=vasco.tests.A}]
Node return : OutValue =[]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.A}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : l0 := @this: java.lang.Object~~~~~~~~~~~~~~~~~~~~~~~~~~~
IN = [{l0=vasco.tests.A}]
Inside NormalFLowFunction : 
IN = [{l0=vasco.tests.A}]
IN : = [{l0=vasco.tests.A}]
OUT = [{l0=vasco.tests.A}]
Setting value after l0 := @this: java.lang.Object
OUT after merge= [{l0=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node return : InValue =[]
Node l0 := @this: java.lang.Object : InValue =[{l0=vasco.tests.A}]
----------OUTVALUES----------
Node return : OutValue =[]
Node l0 := @this: java.lang.Object : OutValue =[{l0=vasco.tests.A}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : return~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of return
predecessor = l0 := @this: java.lang.Object
predOut = [{l0=vasco.tests.A}]
Setting value before return
IN = [{l0=vasco.tests.A}]
Inside NormalFLowFunction : 
IN = [{l0=vasco.tests.A}]
IN : = [{l0=vasco.tests.A}]
OUT = [{l0=vasco.tests.A}]
Setting value after return
OUT after merge= [{l0=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node return : InValue =[{l0=vasco.tests.A}]
Node l0 := @this: java.lang.Object : InValue =[{l0=vasco.tests.A}]
----------OUTVALUES----------
Node return : OutValue =[{l0=vasco.tests.A}]
Node l0 := @this: java.lang.Object : OutValue =[{l0=vasco.tests.A}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke this.<java.lang.Object: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke this.<java.lang.Object: void <init>()>()
predecessor = this := @this: vasco.tests.A
predOut = [{this=vasco.tests.A}]
Setting value before specialinvoke this.<java.lang.Object: void <init>()>()
IN = [{this=vasco.tests.A}]
[HIT] X2 -> X3 <java.lang.Object: void <init>()> 
EXIT(X3) = [{l0=vasco.tests.A}]
IN = [{this=vasco.tests.A}]
IN : = [{this=vasco.tests.A}]
OUT = [{this=vasco.tests.A}]
Setting value after specialinvoke this.<java.lang.Object: void <init>()>()
OUT after merge= [{this=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[{this=vasco.tests.A}]
Node return : InValue =[]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.A}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[{this=vasco.tests.A}]
Node return : OutValue =[]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.A}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : return~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of return
predecessor = specialinvoke this.<java.lang.Object: void <init>()>()
predOut = [{this=vasco.tests.A}]
Setting value before return
IN = [{this=vasco.tests.A}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.A}]
IN : = [{this=vasco.tests.A}]
OUT = [{this=vasco.tests.A}]
Setting value after return
OUT after merge= [{this=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[{this=vasco.tests.A}]
Node return : InValue =[{this=vasco.tests.A}]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.A}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[{this=vasco.tests.A}]
Node return : OutValue =[{this=vasco.tests.A}]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.A}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke $r0.<vasco.tests.A: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke $r0.<vasco.tests.A: void <init>()>()
predecessor = $r0 = new vasco.tests.A
predOut = [{$r0=vasco.tests.A}]
Setting value before specialinvoke $r0.<vasco.tests.A: void <init>()>()
IN = [{$r0=vasco.tests.A}]
[HIT] X1 -> X2 <vasco.tests.A: void <init>()> 
EXIT(X2) = [{this=vasco.tests.A}]
IN = [{$r0=vasco.tests.A}]
IN : = [{$r0=vasco.tests.A}]
OUT = [{$r0=vasco.tests.A}]
Setting value after specialinvoke $r0.<vasco.tests.A: void <init>()>()
OUT after merge= [{$r0=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[]
Node b = $r1 : InValue =[]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[]
Node b = $r1 : OutValue =[]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : a = $r0~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of a = $r0
predecessor = specialinvoke $r0.<vasco.tests.A: void <init>()>()
predOut = [{$r0=vasco.tests.A}]
Setting value before a = $r0
IN = [{$r0=vasco.tests.A}]
Inside NormalFLowFunction : 
IN = [{$r0=vasco.tests.A}]
IN : = [{$r0=vasco.tests.A}]
OUT = [{$r0=vasco.tests.A, a=vasco.tests.A}]
Setting value after a = $r0
OUT after merge= [{$r0=vasco.tests.A, a=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[]
Node b = $r1 : InValue =[]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[]
Node b = $r1 : OutValue =[]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : $r1 = new vasco.tests.B~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of $r1 = new vasco.tests.B
predecessor = a = $r0
predOut = [{$r0=vasco.tests.A, a=vasco.tests.A}]
Setting value before $r1 = new vasco.tests.B
IN = [{$r0=vasco.tests.A, a=vasco.tests.A}]
Inside NormalFLowFunction : 
IN = [{$r0=vasco.tests.A, a=vasco.tests.A}]
IN : = [{$r0=vasco.tests.A, a=vasco.tests.A}]
OUT = [{$r0=vasco.tests.A, $r1=vasco.tests.B, a=vasco.tests.A}]
Setting value after $r1 = new vasco.tests.B
OUT after merge= [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[]
Node b = $r1 : InValue =[]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[]
Node b = $r1 : OutValue =[]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke $r1.<vasco.tests.B: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke $r1.<vasco.tests.B: void <init>()>()
predecessor = $r1 = new vasco.tests.B
predOut = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Setting value before specialinvoke $r1.<vasco.tests.B: void <init>()>()
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Setting value before this := @this: vasco.tests.B
Setting value after this := @this: vasco.tests.B
Setting value before specialinvoke this.<vasco.tests.A: void <init>()>()
Setting value after specialinvoke this.<vasco.tests.A: void <init>()>()
Setting value before return
Setting value after return
Setting value before this := @this: vasco.tests.B
[NEW] X1 -> X4 <vasco.tests.B: void <init>()> 
ENTRY(X4) = [{this=vasco.tests.B}]
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
IN : = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
OUT = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Setting value after specialinvoke $r1.<vasco.tests.B: void <init>()>()
OUT after merge= [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[]
Node b = $r1 : InValue =[]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[]
Node b = $r1 : OutValue =[]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : this := @this: vasco.tests.B~~~~~~~~~~~~~~~~~~~~~~~~~~~
IN = [{this=vasco.tests.B}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.B}]
IN : = [{this=vasco.tests.B}]
OUT = [{this=vasco.tests.B}]
Setting value after this := @this: vasco.tests.B
OUT after merge= [{this=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<vasco.tests.A: void <init>()>() : InValue =[]
Node return : InValue =[]
Node this := @this: vasco.tests.B : InValue =[{this=vasco.tests.B}]
----------OUTVALUES----------
Node specialinvoke this.<vasco.tests.A: void <init>()>() : OutValue =[]
Node return : OutValue =[]
Node this := @this: vasco.tests.B : OutValue =[{this=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke this.<vasco.tests.A: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke this.<vasco.tests.A: void <init>()>()
predecessor = this := @this: vasco.tests.B
predOut = [{this=vasco.tests.B}]
Setting value before specialinvoke this.<vasco.tests.A: void <init>()>()
IN = [{this=vasco.tests.B}]
Setting value before this := @this: vasco.tests.A
Setting value after this := @this: vasco.tests.A
Setting value before specialinvoke this.<java.lang.Object: void <init>()>()
Setting value after specialinvoke this.<java.lang.Object: void <init>()>()
Setting value before return
Setting value after return
Setting value before this := @this: vasco.tests.A
[NEW] X4 -> X5 <vasco.tests.A: void <init>()> 
ENTRY(X5) = [{this=vasco.tests.B}]
IN = [{this=vasco.tests.B}]
IN : = [{this=vasco.tests.B}]
OUT = [{this=vasco.tests.B}]
Setting value after specialinvoke this.<vasco.tests.A: void <init>()>()
OUT after merge= [{this=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<vasco.tests.A: void <init>()>() : InValue =[{this=vasco.tests.B}]
Node return : InValue =[]
Node this := @this: vasco.tests.B : InValue =[{this=vasco.tests.B}]
----------OUTVALUES----------
Node specialinvoke this.<vasco.tests.A: void <init>()>() : OutValue =[{this=vasco.tests.B}]
Node return : OutValue =[]
Node this := @this: vasco.tests.B : OutValue =[{this=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : this := @this: vasco.tests.A~~~~~~~~~~~~~~~~~~~~~~~~~~~
IN = [{this=vasco.tests.B}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.B}]
IN : = [{this=vasco.tests.B}]
OUT = [{this=vasco.tests.B}]
Setting value after this := @this: vasco.tests.A
OUT after merge= [{this=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[]
Node return : InValue =[]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.B}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[]
Node return : OutValue =[]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke this.<java.lang.Object: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke this.<java.lang.Object: void <init>()>()
predecessor = this := @this: vasco.tests.A
predOut = [{this=vasco.tests.B}]
Setting value before specialinvoke this.<java.lang.Object: void <init>()>()
IN = [{this=vasco.tests.B}]
Setting value before l0 := @this: java.lang.Object
Setting value after l0 := @this: java.lang.Object
Setting value before return
Setting value after return
Setting value before l0 := @this: java.lang.Object
[NEW] X5 -> X6 <java.lang.Object: void <init>()> 
ENTRY(X6) = [{l0=vasco.tests.B}]
IN = [{this=vasco.tests.B}]
IN : = [{this=vasco.tests.B}]
OUT = [{this=vasco.tests.B}]
Setting value after specialinvoke this.<java.lang.Object: void <init>()>()
OUT after merge= [{this=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[{this=vasco.tests.B}]
Node return : InValue =[]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.B}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[{this=vasco.tests.B}]
Node return : OutValue =[]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : l0 := @this: java.lang.Object~~~~~~~~~~~~~~~~~~~~~~~~~~~
IN = [{l0=vasco.tests.B}]
Inside NormalFLowFunction : 
IN = [{l0=vasco.tests.B}]
IN : = [{l0=vasco.tests.B}]
OUT = [{l0=vasco.tests.B}]
Setting value after l0 := @this: java.lang.Object
OUT after merge= [{l0=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node return : InValue =[]
Node l0 := @this: java.lang.Object : InValue =[{l0=vasco.tests.B}]
----------OUTVALUES----------
Node return : OutValue =[]
Node l0 := @this: java.lang.Object : OutValue =[{l0=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : return~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of return
predecessor = l0 := @this: java.lang.Object
predOut = [{l0=vasco.tests.B}]
Setting value before return
IN = [{l0=vasco.tests.B}]
Inside NormalFLowFunction : 
IN = [{l0=vasco.tests.B}]
IN : = [{l0=vasco.tests.B}]
OUT = [{l0=vasco.tests.B}]
Setting value after return
OUT after merge= [{l0=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node return : InValue =[{l0=vasco.tests.B}]
Node l0 := @this: java.lang.Object : InValue =[{l0=vasco.tests.B}]
----------OUTVALUES----------
Node return : OutValue =[{l0=vasco.tests.B}]
Node l0 := @this: java.lang.Object : OutValue =[{l0=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke this.<java.lang.Object: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke this.<java.lang.Object: void <init>()>()
predecessor = this := @this: vasco.tests.A
predOut = [{this=vasco.tests.B}]
Setting value before specialinvoke this.<java.lang.Object: void <init>()>()
IN = [{this=vasco.tests.B}]
[HIT] X5 -> X6 <java.lang.Object: void <init>()> 
EXIT(X6) = [{l0=vasco.tests.B}]
IN = [{this=vasco.tests.B}]
IN : = [{this=vasco.tests.B}]
OUT = [{this=vasco.tests.B}]
Setting value after specialinvoke this.<java.lang.Object: void <init>()>()
OUT after merge= [{this=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[{this=vasco.tests.B}]
Node return : InValue =[]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.B}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[{this=vasco.tests.B}]
Node return : OutValue =[]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : return~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of return
predecessor = specialinvoke this.<java.lang.Object: void <init>()>()
predOut = [{this=vasco.tests.B}]
Setting value before return
IN = [{this=vasco.tests.B}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.B}]
IN : = [{this=vasco.tests.B}]
OUT = [{this=vasco.tests.B}]
Setting value after return
OUT after merge= [{this=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[{this=vasco.tests.B}]
Node return : InValue =[{this=vasco.tests.B}]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.B}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[{this=vasco.tests.B}]
Node return : OutValue =[{this=vasco.tests.B}]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke this.<vasco.tests.A: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke this.<vasco.tests.A: void <init>()>()
predecessor = this := @this: vasco.tests.B
predOut = [{this=vasco.tests.B}]
Setting value before specialinvoke this.<vasco.tests.A: void <init>()>()
IN = [{this=vasco.tests.B}]
[HIT] X4 -> X5 <vasco.tests.A: void <init>()> 
EXIT(X5) = [{this=vasco.tests.B}]
IN = [{this=vasco.tests.B}]
IN : = [{this=vasco.tests.B}]
OUT = [{this=vasco.tests.B}]
Setting value after specialinvoke this.<vasco.tests.A: void <init>()>()
OUT after merge= [{this=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<vasco.tests.A: void <init>()>() : InValue =[{this=vasco.tests.B}]
Node return : InValue =[]
Node this := @this: vasco.tests.B : InValue =[{this=vasco.tests.B}]
----------OUTVALUES----------
Node specialinvoke this.<vasco.tests.A: void <init>()>() : OutValue =[{this=vasco.tests.B}]
Node return : OutValue =[]
Node this := @this: vasco.tests.B : OutValue =[{this=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : return~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of return
predecessor = specialinvoke this.<vasco.tests.A: void <init>()>()
predOut = [{this=vasco.tests.B}]
Setting value before return
IN = [{this=vasco.tests.B}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.B}]
IN : = [{this=vasco.tests.B}]
OUT = [{this=vasco.tests.B}]
Setting value after return
OUT after merge= [{this=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<vasco.tests.A: void <init>()>() : InValue =[{this=vasco.tests.B}]
Node return : InValue =[{this=vasco.tests.B}]
Node this := @this: vasco.tests.B : InValue =[{this=vasco.tests.B}]
----------OUTVALUES----------
Node specialinvoke this.<vasco.tests.A: void <init>()>() : OutValue =[{this=vasco.tests.B}]
Node return : OutValue =[{this=vasco.tests.B}]
Node this := @this: vasco.tests.B : OutValue =[{this=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke $r1.<vasco.tests.B: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke $r1.<vasco.tests.B: void <init>()>()
predecessor = $r1 = new vasco.tests.B
predOut = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Setting value before specialinvoke $r1.<vasco.tests.B: void <init>()>()
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
[HIT] X1 -> X4 <vasco.tests.B: void <init>()> 
EXIT(X4) = [{this=vasco.tests.B}]
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
IN : = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
OUT = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Setting value after specialinvoke $r1.<vasco.tests.B: void <init>()>()
OUT after merge= [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[]
Node b = $r1 : InValue =[]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[]
Node b = $r1 : OutValue =[]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : b = $r1~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of b = $r1
predecessor = specialinvoke $r1.<vasco.tests.B: void <init>()>()
predOut = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Setting value before b = $r1
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Inside NormalFLowFunction : 
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
IN : = [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
OUT = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Setting value after b = $r1
OUT after merge= [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : $r2 = new vasco.tests.C~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of $r2 = new vasco.tests.C
predecessor = b = $r1
predOut = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Setting value before $r2 = new vasco.tests.C
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Inside NormalFLowFunction : 
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
IN : = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
OUT = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Setting value after $r2 = new vasco.tests.C
OUT after merge= [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke $r2.<vasco.tests.C: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke $r2.<vasco.tests.C: void <init>()>()
predecessor = $r2 = new vasco.tests.C
predOut = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Setting value before specialinvoke $r2.<vasco.tests.C: void <init>()>()
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Setting value before this := @this: vasco.tests.C
Setting value after this := @this: vasco.tests.C
Setting value before specialinvoke this.<vasco.tests.A: void <init>()>()
Setting value after specialinvoke this.<vasco.tests.A: void <init>()>()
Setting value before return
Setting value after return
Setting value before this := @this: vasco.tests.C
[NEW] X1 -> X7 <vasco.tests.C: void <init>()> 
ENTRY(X7) = [{this=vasco.tests.C}]
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
IN : = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
OUT = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Setting value after specialinvoke $r2.<vasco.tests.C: void <init>()>()
OUT after merge= [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : this := @this: vasco.tests.C~~~~~~~~~~~~~~~~~~~~~~~~~~~
IN = [{this=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.C}]
IN : = [{this=vasco.tests.C}]
OUT = [{this=vasco.tests.C}]
Setting value after this := @this: vasco.tests.C
OUT after merge= [{this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node return : InValue =[]
Node this := @this: vasco.tests.C : InValue =[{this=vasco.tests.C}]
Node specialinvoke this.<vasco.tests.A: void <init>()>() : InValue =[]
----------OUTVALUES----------
Node return : OutValue =[]
Node this := @this: vasco.tests.C : OutValue =[{this=vasco.tests.C}]
Node specialinvoke this.<vasco.tests.A: void <init>()>() : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke this.<vasco.tests.A: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke this.<vasco.tests.A: void <init>()>()
predecessor = this := @this: vasco.tests.C
predOut = [{this=vasco.tests.C}]
Setting value before specialinvoke this.<vasco.tests.A: void <init>()>()
IN = [{this=vasco.tests.C}]
Setting value before this := @this: vasco.tests.A
Setting value after this := @this: vasco.tests.A
Setting value before specialinvoke this.<java.lang.Object: void <init>()>()
Setting value after specialinvoke this.<java.lang.Object: void <init>()>()
Setting value before return
Setting value after return
Setting value before this := @this: vasco.tests.A
[NEW] X7 -> X8 <vasco.tests.A: void <init>()> 
ENTRY(X8) = [{this=vasco.tests.C}]
IN = [{this=vasco.tests.C}]
IN : = [{this=vasco.tests.C}]
OUT = [{this=vasco.tests.C}]
Setting value after specialinvoke this.<vasco.tests.A: void <init>()>()
OUT after merge= [{this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node return : InValue =[]
Node this := @this: vasco.tests.C : InValue =[{this=vasco.tests.C}]
Node specialinvoke this.<vasco.tests.A: void <init>()>() : InValue =[{this=vasco.tests.C}]
----------OUTVALUES----------
Node return : OutValue =[]
Node this := @this: vasco.tests.C : OutValue =[{this=vasco.tests.C}]
Node specialinvoke this.<vasco.tests.A: void <init>()>() : OutValue =[{this=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : this := @this: vasco.tests.A~~~~~~~~~~~~~~~~~~~~~~~~~~~
IN = [{this=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.C}]
IN : = [{this=vasco.tests.C}]
OUT = [{this=vasco.tests.C}]
Setting value after this := @this: vasco.tests.A
OUT after merge= [{this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[]
Node return : InValue =[]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.C}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[]
Node return : OutValue =[]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke this.<java.lang.Object: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke this.<java.lang.Object: void <init>()>()
predecessor = this := @this: vasco.tests.A
predOut = [{this=vasco.tests.C}]
Setting value before specialinvoke this.<java.lang.Object: void <init>()>()
IN = [{this=vasco.tests.C}]
Setting value before l0 := @this: java.lang.Object
Setting value after l0 := @this: java.lang.Object
Setting value before return
Setting value after return
Setting value before l0 := @this: java.lang.Object
[NEW] X8 -> X9 <java.lang.Object: void <init>()> 
ENTRY(X9) = [{l0=vasco.tests.C}]
IN = [{this=vasco.tests.C}]
IN : = [{this=vasco.tests.C}]
OUT = [{this=vasco.tests.C}]
Setting value after specialinvoke this.<java.lang.Object: void <init>()>()
OUT after merge= [{this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[{this=vasco.tests.C}]
Node return : InValue =[]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.C}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[{this=vasco.tests.C}]
Node return : OutValue =[]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : l0 := @this: java.lang.Object~~~~~~~~~~~~~~~~~~~~~~~~~~~
IN = [{l0=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{l0=vasco.tests.C}]
IN : = [{l0=vasco.tests.C}]
OUT = [{l0=vasco.tests.C}]
Setting value after l0 := @this: java.lang.Object
OUT after merge= [{l0=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node return : InValue =[]
Node l0 := @this: java.lang.Object : InValue =[{l0=vasco.tests.C}]
----------OUTVALUES----------
Node return : OutValue =[]
Node l0 := @this: java.lang.Object : OutValue =[{l0=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : return~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of return
predecessor = l0 := @this: java.lang.Object
predOut = [{l0=vasco.tests.C}]
Setting value before return
IN = [{l0=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{l0=vasco.tests.C}]
IN : = [{l0=vasco.tests.C}]
OUT = [{l0=vasco.tests.C}]
Setting value after return
OUT after merge= [{l0=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node return : InValue =[{l0=vasco.tests.C}]
Node l0 := @this: java.lang.Object : InValue =[{l0=vasco.tests.C}]
----------OUTVALUES----------
Node return : OutValue =[{l0=vasco.tests.C}]
Node l0 := @this: java.lang.Object : OutValue =[{l0=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke this.<java.lang.Object: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke this.<java.lang.Object: void <init>()>()
predecessor = this := @this: vasco.tests.A
predOut = [{this=vasco.tests.C}]
Setting value before specialinvoke this.<java.lang.Object: void <init>()>()
IN = [{this=vasco.tests.C}]
[HIT] X8 -> X9 <java.lang.Object: void <init>()> 
EXIT(X9) = [{l0=vasco.tests.C}]
IN = [{this=vasco.tests.C}]
IN : = [{this=vasco.tests.C}]
OUT = [{this=vasco.tests.C}]
Setting value after specialinvoke this.<java.lang.Object: void <init>()>()
OUT after merge= [{this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[{this=vasco.tests.C}]
Node return : InValue =[]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.C}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[{this=vasco.tests.C}]
Node return : OutValue =[]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : return~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of return
predecessor = specialinvoke this.<java.lang.Object: void <init>()>()
predOut = [{this=vasco.tests.C}]
Setting value before return
IN = [{this=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.C}]
IN : = [{this=vasco.tests.C}]
OUT = [{this=vasco.tests.C}]
Setting value after return
OUT after merge= [{this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : InValue =[{this=vasco.tests.C}]
Node return : InValue =[{this=vasco.tests.C}]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.C}]
----------OUTVALUES----------
Node specialinvoke this.<java.lang.Object: void <init>()>() : OutValue =[{this=vasco.tests.C}]
Node return : OutValue =[{this=vasco.tests.C}]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke this.<vasco.tests.A: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke this.<vasco.tests.A: void <init>()>()
predecessor = this := @this: vasco.tests.C
predOut = [{this=vasco.tests.C}]
Setting value before specialinvoke this.<vasco.tests.A: void <init>()>()
IN = [{this=vasco.tests.C}]
[HIT] X7 -> X8 <vasco.tests.A: void <init>()> 
EXIT(X8) = [{this=vasco.tests.C}]
IN = [{this=vasco.tests.C}]
IN : = [{this=vasco.tests.C}]
OUT = [{this=vasco.tests.C}]
Setting value after specialinvoke this.<vasco.tests.A: void <init>()>()
OUT after merge= [{this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node return : InValue =[]
Node this := @this: vasco.tests.C : InValue =[{this=vasco.tests.C}]
Node specialinvoke this.<vasco.tests.A: void <init>()>() : InValue =[{this=vasco.tests.C}]
----------OUTVALUES----------
Node return : OutValue =[]
Node this := @this: vasco.tests.C : OutValue =[{this=vasco.tests.C}]
Node specialinvoke this.<vasco.tests.A: void <init>()>() : OutValue =[{this=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : return~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of return
predecessor = specialinvoke this.<vasco.tests.A: void <init>()>()
predOut = [{this=vasco.tests.C}]
Setting value before return
IN = [{this=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.C}]
IN : = [{this=vasco.tests.C}]
OUT = [{this=vasco.tests.C}]
Setting value after return
OUT after merge= [{this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node return : InValue =[{this=vasco.tests.C}]
Node this := @this: vasco.tests.C : InValue =[{this=vasco.tests.C}]
Node specialinvoke this.<vasco.tests.A: void <init>()>() : InValue =[{this=vasco.tests.C}]
----------OUTVALUES----------
Node return : OutValue =[{this=vasco.tests.C}]
Node this := @this: vasco.tests.C : OutValue =[{this=vasco.tests.C}]
Node specialinvoke this.<vasco.tests.A: void <init>()>() : OutValue =[{this=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : specialinvoke $r2.<vasco.tests.C: void <init>()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of specialinvoke $r2.<vasco.tests.C: void <init>()>()
predecessor = $r2 = new vasco.tests.C
predOut = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Setting value before specialinvoke $r2.<vasco.tests.C: void <init>()>()
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
[HIT] X1 -> X7 <vasco.tests.C: void <init>()> 
EXIT(X7) = [{this=vasco.tests.C}]
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
IN : = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
OUT = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Setting value after specialinvoke $r2.<vasco.tests.C: void <init>()>()
OUT after merge= [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : c = $r2~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of c = $r2
predecessor = specialinvoke $r2.<vasco.tests.C: void <init>()>()
predOut = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Setting value before c = $r2
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Inside NormalFLowFunction : 
IN = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
IN : = [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
OUT = [{$r0=vasco.tests.A, c=vasco.tests.C, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Setting value after c = $r2
OUT after merge= [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : if i <= 0 goto a = c~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of if i <= 0 goto a = c
predecessor = c = $r2
predOut = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Setting value before if i <= 0 goto a = c
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Inside NormalFLowFunction : 
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
IN : = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
OUT = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Setting value after if i <= 0 goto a = c
OUT after merge= [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : a = b~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of a = b
predecessor = if i <= 0 goto a = c
predOut = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Setting value before a = b
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Inside NormalFLowFunction : 
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
IN : = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
OUT = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Setting value after a = b
OUT after merge= [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : goto [?= i#4 = 0]~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of goto [?= i#4 = 0]
predecessor = a = b
predOut = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Setting value before goto [?= i#4 = 0]
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Inside NormalFLowFunction : 
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
IN : = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
OUT = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Setting value after goto [?= i#4 = 0]
OUT after merge= [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : InValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : OutValue =[]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : a = c~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of a = c
predecessor = if i <= 0 goto a = c
predOut = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Setting value before a = c
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Inside NormalFLowFunction : 
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
IN : = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
OUT = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Setting value after a = c
OUT after merge= [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : i#4 = 0~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of i#4 = 0
predecessor = goto [?= i#4 = 0]
predOut = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
predecessor = a = c
predOut = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Setting value before i#4 = 0
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
IN : = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
OUT = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Setting value after i#4 = 0
OUT after merge= [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[]
Node if i <= 0 goto a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[]
Node if i <= 0 goto a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : virtualinvoke a.<vasco.tests.A: void m()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of virtualinvoke a.<vasco.tests.A: void m()>()
predecessor = i#4 = 0
predOut = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Setting value before virtualinvoke a.<vasco.tests.A: void m()>()
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Setting value before this := @this: vasco.tests.A
Setting value after this := @this: vasco.tests.A
Setting value before $r0 = <java.lang.System: java.io.PrintStream out>
Setting value after $r0 = <java.lang.System: java.io.PrintStream out>
Setting value before virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A")
Setting value after virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A")
Setting value before return
Setting value after return
Setting value before this := @this: vasco.tests.A
[NEW] X1 -> X10 <vasco.tests.A: void m()> 
ENTRY(X10) = [{this=vasco.tests.B}, {this=vasco.tests.C}]
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
IN : = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
OUT = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Setting value after virtualinvoke a.<vasco.tests.A: void m()>()
OUT after merge= [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node if i <= 0 goto a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node if i <= 0 goto a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : this := @this: vasco.tests.A~~~~~~~~~~~~~~~~~~~~~~~~~~~
IN = [{this=vasco.tests.B}, {this=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.B}, {this=vasco.tests.C}]
IN : = [{this=vasco.tests.B}, {this=vasco.tests.C}]
OUT = [{this=vasco.tests.B}, {this=vasco.tests.C}]
Setting value after this := @this: vasco.tests.A
OUT after merge= [{this=vasco.tests.B}, {this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A") : InValue =[]
Node $r0 = <java.lang.System: java.io.PrintStream out> : InValue =[]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node return : InValue =[]
----------OUTVALUES----------
Node virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A") : OutValue =[]
Node $r0 = <java.lang.System: java.io.PrintStream out> : OutValue =[]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node return : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : $r0 = <java.lang.System: java.io.PrintStream out>~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of $r0 = <java.lang.System: java.io.PrintStream out>
predecessor = this := @this: vasco.tests.A
predOut = [{this=vasco.tests.B}, {this=vasco.tests.C}]
Setting value before $r0 = <java.lang.System: java.io.PrintStream out>
IN = [{this=vasco.tests.B}, {this=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.B}, {this=vasco.tests.C}]
IN : = [{this=vasco.tests.B}, {this=vasco.tests.C}]
OUT = [{this=vasco.tests.B}, {this=vasco.tests.C}]
Setting value after $r0 = <java.lang.System: java.io.PrintStream out>
OUT after merge= [{this=vasco.tests.B}, {this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A") : InValue =[]
Node $r0 = <java.lang.System: java.io.PrintStream out> : InValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node return : InValue =[]
----------OUTVALUES----------
Node virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A") : OutValue =[]
Node $r0 = <java.lang.System: java.io.PrintStream out> : OutValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node return : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A")~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A")
predecessor = $r0 = <java.lang.System: java.io.PrintStream out>
predOut = [{this=vasco.tests.B}, {this=vasco.tests.C}]
Setting value before virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A")
IN = [{this=vasco.tests.B}, {this=vasco.tests.C}]
IN = [{this=vasco.tests.B}, {this=vasco.tests.C}]
IN : = [{this=vasco.tests.B}, {this=vasco.tests.C}]
OUT = [{this=vasco.tests.B}, {this=vasco.tests.C}]
Setting value after virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A")
OUT after merge= [{this=vasco.tests.B}, {this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A") : InValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node $r0 = <java.lang.System: java.io.PrintStream out> : InValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node return : InValue =[]
----------OUTVALUES----------
Node virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A") : OutValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node $r0 = <java.lang.System: java.io.PrintStream out> : OutValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node return : OutValue =[]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : return~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of return
predecessor = virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A")
predOut = [{this=vasco.tests.B}, {this=vasco.tests.C}]
Setting value before return
IN = [{this=vasco.tests.B}, {this=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{this=vasco.tests.B}, {this=vasco.tests.C}]
IN : = [{this=vasco.tests.B}, {this=vasco.tests.C}]
OUT = [{this=vasco.tests.B}, {this=vasco.tests.C}]
Setting value after return
OUT after merge= [{this=vasco.tests.B}, {this=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A") : InValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node $r0 = <java.lang.System: java.io.PrintStream out> : InValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node this := @this: vasco.tests.A : InValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node return : InValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
----------OUTVALUES----------
Node virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A") : OutValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node $r0 = <java.lang.System: java.io.PrintStream out> : OutValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node this := @this: vasco.tests.A : OutValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
Node return : OutValue =[{this=vasco.tests.B}, {this=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : virtualinvoke a.<vasco.tests.A: void m()>()~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of virtualinvoke a.<vasco.tests.A: void m()>()
predecessor = i#4 = 0
predOut = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Setting value before virtualinvoke a.<vasco.tests.A: void m()>()
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
[HIT] X1 -> X10 <vasco.tests.A: void m()> 
EXIT(X10) = [{this=vasco.tests.B}, {this=vasco.tests.C}]
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
IN : = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
OUT = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Setting value after virtualinvoke a.<vasco.tests.A: void m()>()
OUT after merge= [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node if i <= 0 goto a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : InValue =[]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node if i <= 0 goto a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : OutValue =[]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NODE : return~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------Merging OUT values of predecessors of return
predecessor = virtualinvoke a.<vasco.tests.A: void m()>()
predOut = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Setting value before return
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Inside NormalFLowFunction : 
IN = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
IN : = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
OUT = [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Setting value after return
OUT after merge= [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
---------------------------------------
----------INVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node if i <= 0 goto a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : InValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node $r2 = new vasco.tests.C : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node b = $r1 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : InValue =[]
Node a = $r0 : InValue =[{$r0=vasco.tests.A}]
Node goto [?= i#4 = 0] : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node args := @parameter0: java.lang.String[] : InValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node $r1 = new vasco.tests.B : InValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node i = 2 : InValue =[]
Node a = b : InValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
----------OUTVALUES----------
Node virtualinvoke a.<vasco.tests.A: void m()>() : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node if i <= 0 goto a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node a = c : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node specialinvoke $r0.<vasco.tests.A: void <init>()>() : OutValue =[{$r0=vasco.tests.A}]
Node i#4 = 0 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node $r2 = new vasco.tests.C : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node b = $r1 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
Node $r0 = new vasco.tests.A : OutValue =[{$r0=vasco.tests.A}]
Node a = $r0 : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A}]
Node goto [?= i#4 = 0] : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
Node return : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
Node args := @parameter0: java.lang.String[] : OutValue =[]
Node specialinvoke $r2.<vasco.tests.C: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
Node specialinvoke $r1.<vasco.tests.B: void <init>()>() : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node c = $r2 : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
Node $r1 = new vasco.tests.B : OutValue =[{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
Node i = 2 : OutValue =[]
Node a = b : OutValue =[{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~Method: <java.lang.Object: void <init>()>~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------Node: l0 := @this: java.lang.Object-----------------------
IN: [{l0=vasco.tests.A}]
OUT: [{l0=vasco.tests.A}]
IN: [{l0=vasco.tests.A}, {l0=vasco.tests.B}]
OUT: [{l0=vasco.tests.A}, {l0=vasco.tests.B}]
IN: [{l0=vasco.tests.A}, {l0=vasco.tests.B}, {l0=vasco.tests.C}]
OUT: [{l0=vasco.tests.A}, {l0=vasco.tests.B}, {l0=vasco.tests.C}]
----------------------------------Node: return-----------------------
IN: [{l0=vasco.tests.A}]
OUT: [{l0=vasco.tests.A}]
IN: [{l0=vasco.tests.A}, {l0=vasco.tests.B}]
OUT: [{l0=vasco.tests.A}, {l0=vasco.tests.B}]
IN: [{l0=vasco.tests.A}, {l0=vasco.tests.B}, {l0=vasco.tests.C}]
OUT: [{l0=vasco.tests.A}, {l0=vasco.tests.B}, {l0=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~Method: <vasco.tests.C: void <init>()>~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------Node: this := @this: vasco.tests.C-----------------------
IN: [{this=vasco.tests.C}]
OUT: [{this=vasco.tests.C}]
----------------------------------Node: specialinvoke this.<vasco.tests.A: void <init>()>()-----------------------
IN: [{this=vasco.tests.C}]
OUT: [{this=vasco.tests.C}]
----------------------------------Node: return-----------------------
IN: [{this=vasco.tests.C}]
OUT: [{this=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~Method: <vasco.tests.B: void <init>()>~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------Node: this := @this: vasco.tests.B-----------------------
IN: [{this=vasco.tests.B}]
OUT: [{this=vasco.tests.B}]
----------------------------------Node: specialinvoke this.<vasco.tests.A: void <init>()>()-----------------------
IN: [{this=vasco.tests.B}]
OUT: [{this=vasco.tests.B}]
----------------------------------Node: return-----------------------
IN: [{this=vasco.tests.B}]
OUT: [{this=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~Method: <vasco.tests.A: void <init>()>~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------Node: this := @this: vasco.tests.A-----------------------
IN: [{this=vasco.tests.A}]
OUT: [{this=vasco.tests.A}]
IN: [{this=vasco.tests.A}, {this=vasco.tests.B}]
OUT: [{this=vasco.tests.A}, {this=vasco.tests.B}]
IN: [{this=vasco.tests.C}, {this=vasco.tests.A}, {this=vasco.tests.B}]
OUT: [{this=vasco.tests.C}, {this=vasco.tests.A}, {this=vasco.tests.B}]
----------------------------------Node: specialinvoke this.<java.lang.Object: void <init>()>()-----------------------
IN: [{this=vasco.tests.A}]
OUT: [{this=vasco.tests.A}]
IN: [{this=vasco.tests.A}, {this=vasco.tests.B}]
OUT: [{this=vasco.tests.A}, {this=vasco.tests.B}]
IN: [{this=vasco.tests.C}, {this=vasco.tests.A}, {this=vasco.tests.B}]
OUT: [{this=vasco.tests.C}, {this=vasco.tests.A}, {this=vasco.tests.B}]
----------------------------------Node: return-----------------------
IN: [{this=vasco.tests.A}]
OUT: [{this=vasco.tests.A}]
IN: [{this=vasco.tests.A}, {this=vasco.tests.B}]
OUT: [{this=vasco.tests.A}, {this=vasco.tests.B}]
IN: [{this=vasco.tests.C}, {this=vasco.tests.A}, {this=vasco.tests.B}]
OUT: [{this=vasco.tests.C}, {this=vasco.tests.A}, {this=vasco.tests.B}]
~~~~~~~~~~~~~~~~~~~~Method: <vasco.tests.A: void m()>~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------Node: this := @this: vasco.tests.A-----------------------
IN: [{this=vasco.tests.B}, {this=vasco.tests.C}]
OUT: [{this=vasco.tests.B}, {this=vasco.tests.C}]
----------------------------------Node: $r0 = <java.lang.System: java.io.PrintStream out>-----------------------
IN: [{this=vasco.tests.B}, {this=vasco.tests.C}]
OUT: [{this=vasco.tests.B}, {this=vasco.tests.C}]
----------------------------------Node: virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A")-----------------------
IN: [{this=vasco.tests.B}, {this=vasco.tests.C}]
OUT: [{this=vasco.tests.B}, {this=vasco.tests.C}]
----------------------------------Node: return-----------------------
IN: [{this=vasco.tests.B}, {this=vasco.tests.C}]
OUT: [{this=vasco.tests.B}, {this=vasco.tests.C}]
~~~~~~~~~~~~~~~~~~~~Method: <vasco.tests.A: void main(java.lang.String[])>~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------Node: args := @parameter0: java.lang.String[]-----------------------
IN: []
OUT: []
----------------------------------Node: i = 2-----------------------
IN: []
OUT: []
----------------------------------Node: $r0 = new vasco.tests.A-----------------------
IN: []
OUT: [{$r0=vasco.tests.A}]
----------------------------------Node: specialinvoke $r0.<vasco.tests.A: void <init>()>()-----------------------
IN: [{$r0=vasco.tests.A}]
OUT: [{$r0=vasco.tests.A}]
----------------------------------Node: a = $r0-----------------------
IN: [{$r0=vasco.tests.A}]
OUT: [{$r0=vasco.tests.A, a=vasco.tests.A}]
----------------------------------Node: $r1 = new vasco.tests.B-----------------------
IN: [{$r0=vasco.tests.A, a=vasco.tests.A}]
OUT: [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
----------------------------------Node: specialinvoke $r1.<vasco.tests.B: void <init>()>()-----------------------
IN: [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
OUT: [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
----------------------------------Node: b = $r1-----------------------
IN: [{$r0=vasco.tests.A, a=vasco.tests.A, $r1=vasco.tests.B}]
OUT: [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
----------------------------------Node: $r2 = new vasco.tests.C-----------------------
IN: [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r1=vasco.tests.B}]
OUT: [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
----------------------------------Node: specialinvoke $r2.<vasco.tests.C: void <init>()>()-----------------------
IN: [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
OUT: [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
----------------------------------Node: c = $r2-----------------------
IN: [{$r0=vasco.tests.A, a=vasco.tests.A, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B}]
OUT: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
----------------------------------Node: if i <= 0 goto a = c-----------------------
IN: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
OUT: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
----------------------------------Node: a = b-----------------------
IN: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
OUT: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
----------------------------------Node: goto [?= i#4 = 0]-----------------------
IN: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
OUT: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}]
----------------------------------Node: a = c-----------------------
IN: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.A}]
OUT: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
----------------------------------Node: i#4 = 0-----------------------
IN: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
OUT: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
----------------------------------Node: virtualinvoke a.<vasco.tests.A: void m()>()-----------------------
IN: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
OUT: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
----------------------------------Node: return-----------------------
IN: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
OUT: [{c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.B}, {c=vasco.tests.C, b=vasco.tests.B, $r2=vasco.tests.C, $r1=vasco.tests.B, $r0=vasco.tests.A, a=vasco.tests.C}]
--------wjtp.rf & {enabled=true}-----------
------------------------------------ANALYSIS METHODS--------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   METHOD NAME: <java.lang.Object: void <init>()>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------IN & OUT :l0 := @this: java.lang.Object  ------------------------------
IN:  Refers-to Relation: l0-> vasco.tests.A,
Refers-to Relation: l0-> vasco.tests.B,
Refers-to Relation: l0-> vasco.tests.C,

OUT: Refers-to Relation: l0-> vasco.tests.A,
Refers-to Relation: l0-> vasco.tests.B,
Refers-to Relation: l0-> vasco.tests.C,

-------------------------IN & OUT :return  ------------------------------
IN:  Refers-to Relation: l0-> vasco.tests.A,
Refers-to Relation: l0-> vasco.tests.B,
Refers-to Relation: l0-> vasco.tests.C,

OUT: Refers-to Relation: l0-> vasco.tests.A,
Refers-to Relation: l0-> vasco.tests.B,
Refers-to Relation: l0-> vasco.tests.C,

----------------------END OF METHOD-----------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   METHOD NAME: <vasco.tests.C: void <init>()>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------IN & OUT :this := @this: vasco.tests.C  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.C,

OUT: Refers-to Relation: this-> vasco.tests.C,

-------------------------IN & OUT :specialinvoke this.<vasco.tests.A: void <init>()>()  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.C,

OUT: Refers-to Relation: this-> vasco.tests.C,

-------------------------IN & OUT :return  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.C,

OUT: Refers-to Relation: this-> vasco.tests.C,

----------------------END OF METHOD-----------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   METHOD NAME: <vasco.tests.B: void <init>()>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------IN & OUT :this := @this: vasco.tests.B  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.B,

OUT: Refers-to Relation: this-> vasco.tests.B,

-------------------------IN & OUT :specialinvoke this.<vasco.tests.A: void <init>()>()  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.B,

OUT: Refers-to Relation: this-> vasco.tests.B,

-------------------------IN & OUT :return  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.B,

OUT: Refers-to Relation: this-> vasco.tests.B,

----------------------END OF METHOD-----------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   METHOD NAME: <vasco.tests.A: void <init>()>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------IN & OUT :this := @this: vasco.tests.A  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.C,
Refers-to Relation: this-> vasco.tests.A,
Refers-to Relation: this-> vasco.tests.B,

OUT: Refers-to Relation: this-> vasco.tests.C,
Refers-to Relation: this-> vasco.tests.A,
Refers-to Relation: this-> vasco.tests.B,

-------------------------IN & OUT :specialinvoke this.<java.lang.Object: void <init>()>()  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.C,
Refers-to Relation: this-> vasco.tests.A,
Refers-to Relation: this-> vasco.tests.B,

OUT: Refers-to Relation: this-> vasco.tests.C,
Refers-to Relation: this-> vasco.tests.A,
Refers-to Relation: this-> vasco.tests.B,

-------------------------IN & OUT :return  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.C,
Refers-to Relation: this-> vasco.tests.A,
Refers-to Relation: this-> vasco.tests.B,

OUT: Refers-to Relation: this-> vasco.tests.C,
Refers-to Relation: this-> vasco.tests.A,
Refers-to Relation: this-> vasco.tests.B,

----------------------END OF METHOD-----------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   METHOD NAME: <vasco.tests.A: void m()>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------IN & OUT :this := @this: vasco.tests.A  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.B,
Refers-to Relation: this-> vasco.tests.C,

OUT: Refers-to Relation: this-> vasco.tests.B,
Refers-to Relation: this-> vasco.tests.C,

-------------------------IN & OUT :$r0 = <java.lang.System: java.io.PrintStream out>  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.B,
Refers-to Relation: this-> vasco.tests.C,

OUT: Refers-to Relation: this-> vasco.tests.B,
Refers-to Relation: this-> vasco.tests.C,

-------------------------IN & OUT :virtualinvoke $r0.<java.io.PrintStream: void println(java.lang.String)>("Inside A")  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.B,
Refers-to Relation: this-> vasco.tests.C,

OUT: Refers-to Relation: this-> vasco.tests.B,
Refers-to Relation: this-> vasco.tests.C,

-------------------------IN & OUT :return  ------------------------------
IN:  Refers-to Relation: this-> vasco.tests.B,
Refers-to Relation: this-> vasco.tests.C,

OUT: Refers-to Relation: this-> vasco.tests.B,
Refers-to Relation: this-> vasco.tests.C,

----------------------END OF METHOD-----------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   METHOD NAME: <vasco.tests.A: void main(java.lang.String[])>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------IN & OUT :args := @parameter0: java.lang.String[]  ------------------------------
IN:  
OUT: 
-------------------------IN & OUT :i = 2  ------------------------------
IN:  
OUT: 
-------------------------IN & OUT :$r0 = new vasco.tests.A  ------------------------------
IN:  
OUT: Refers-to Relation: $r0-> vasco.tests.A,

-------------------------IN & OUT :specialinvoke $r0.<vasco.tests.A: void <init>()>()  ------------------------------
IN:  Refers-to Relation: $r0-> vasco.tests.A,

OUT: Refers-to Relation: $r0-> vasco.tests.A,

-------------------------IN & OUT :a = $r0  ------------------------------
IN:  Refers-to Relation: $r0-> vasco.tests.A,

OUT: Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A,

-------------------------IN & OUT :$r1 = new vasco.tests.B  ------------------------------
IN:  Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A,

OUT: Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A, $r1-> vasco.tests.B,

-------------------------IN & OUT :specialinvoke $r1.<vasco.tests.B: void <init>()>()  ------------------------------
IN:  Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A, $r1-> vasco.tests.B,

OUT: Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A, $r1-> vasco.tests.B,

-------------------------IN & OUT :b = $r1  ------------------------------
IN:  Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A, $r1-> vasco.tests.B,

OUT: Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A, b-> vasco.tests.B, $r1-> vasco.tests.B,

-------------------------IN & OUT :$r2 = new vasco.tests.C  ------------------------------
IN:  Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A, b-> vasco.tests.B, $r1-> vasco.tests.B,

OUT: Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B,

-------------------------IN & OUT :specialinvoke $r2.<vasco.tests.C: void <init>()>()  ------------------------------
IN:  Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B,

OUT: Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B,

-------------------------IN & OUT :c = $r2  ------------------------------
IN:  Refers-to Relation: $r0-> vasco.tests.A, a-> vasco.tests.A, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B,

OUT: Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.A,

-------------------------IN & OUT :if i <= 0 goto a = c  ------------------------------
IN:  Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.A,

OUT: Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.A,

-------------------------IN & OUT :a = b  ------------------------------
IN:  Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.A,

OUT: Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.B,

-------------------------IN & OUT :goto [?= i#4 = 0]  ------------------------------
IN:  Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.B,

OUT: Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.B,

-------------------------IN & OUT :a = c  ------------------------------
IN:  Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.A,

OUT: Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.C,

-------------------------IN & OUT :i#4 = 0  ------------------------------
IN:  Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.B,
Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.C,

OUT: Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.B,
Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.C,

-------------------------IN & OUT :virtualinvoke a.<vasco.tests.A: void m()>()  ------------------------------
IN:  Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.B,
Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.C,

OUT: Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.B,
Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.C,

-------------------------IN & OUT :return  ------------------------------
IN:  Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.B,
Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.C,

OUT: Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.B,
Refers-to Relation: c-> vasco.tests.C, b-> vasco.tests.B, $r2-> vasco.tests.C, $r1-> vasco.tests.B, $r0-> vasco.tests.A, a-> vasco.tests.C,

----------------------END OF METHOD-----------------------------
Transforming vasco.tests.A... 
Transforming jdk.internal.util.xml.BasicXmlPropertiesProvider... 
Transforming jdk.net.SocketFlow... 
Transforming jdk.net.ExtendedSocketOptions... 
Transforming jdk.internal.util.xml.PropertiesDefaultHandler... 
Transforming jdk.net.NetworkPermission... 
Transforming jdk.internal.org.objectweb.asm.ClassWriter... 
Transforming jdk.internal.org.objectweb.asm.MethodVisitor... 
Transforming jdk.internal.org.objectweb.asm.AnnotationVisitor... 
Transforming jdk.internal.org.objectweb.asm.Label... 
Transforming jdk.net.SocketFlow$Status... 
Transforming jdk.Exported... 
Transforming jdk.net.ExtendedSocketOptions$ExtSocketOption... 
Transforming jdk.internal.org.xml.sax.helpers.DefaultHandler... 
Transforming jdk.internal.org.xml.sax.SAXException... 
Transforming jdk.internal.org.xml.sax.Attributes... 
Transforming jdk.internal.org.xml.sax.InputSource... 
Transforming jdk.internal.org.xml.sax.SAXParseException... 
Transforming jdk.internal.util.xml.impl.XMLStreamWriterImpl... 
Transforming jdk.internal.org.xml.sax.Locator... 
Transforming jdk.internal.util.xml.impl.SAXParserImpl... 
Transforming jdk.internal.util.xml.SAXParser... 
Transforming jdk.internal.util.xml.XMLStreamException... 
Transforming jdk.internal.util.xml.XMLStreamWriter... 
Transforming jdk.internal.org.objectweb.asm.ClassVisitor... 
Transforming Transforming jdk.internal.org.objectweb.asm.Item... 
Transforming jdk.internal.org.objectweb.asm.ByteVector... 
jdk.internal.org.objectweb.asm.ClassReader... 
Transforming jdk.internal.org.objectweb.asm.AnnotationWriter... 
Transforming jdk.internal.org.objectweb.asm.Attribute... 
Transforming jdk.internal.org.objectweb.asm.FieldWriter... 
Transforming jdk.internal.org.objectweb.asm.MethodWriter... 
Transforming jdk.internal.org.objectweb.asm.TypePath... 
Transforming jdk.internal.org.objectweb.asm.FieldVisitor... 
Transforming jdk.internal.org.objectweb.asm.Handle... 
Transforming jdk.internal.org.objectweb.asm.Type... 
Transforming jdk.internal.org.objectweb.asm.Frame... 
Transforming jdk.internal.org.objectweb.asm.Edge... 
Transforming jdk.internal.org.xml.sax.EntityResolver... 
Transforming jdk.internal.org.xml.sax.DTDHandler... 
Transforming jdk.internal.org.xml.sax.ContentHandler... 
Transforming jdk.internal.org.xml.sax.ErrorHandler... 
Transforming jdk.internal.util.xml.impl.XMLStreamWriterImpl$Element... 
Transforming jdk.internal.util.xml.impl.XMLWriter... 
Transforming jdk.internal.util.xml.impl.ParserSAX... 
Transforming jdk.internal.org.xml.sax.XMLReader... 
Transforming jdk.internal.org.objectweb.asm.Handler... 
Transforming jdk.internal.org.objectweb.asm.Context... 
Transforming jdk.internal.org.objectweb.asm.Opcodes... 
Transforming jdk.internal.util.xml.impl.Parser... 
Transforming jdk.internal.util.xml.impl.Pair... 
Transforming jdk.internal.util.xml.impl.Attrs... 
Transforming jdk.internal.util.xml.impl.Input... 
Transforming jdk.internal.org.xml.sax.SAXNotRecognizedException... 
Transforming jdk.internal.org.xml.sax.SAXNotSupportedException... 
Transforming jdk.internal.util.xml.impl.ReaderUTF16... 
Transforming jdk.internal.util.xml.impl.ReaderUTF8... 
Transforming vasco.tests.B... 
Transforming vasco.tests.C... 
Soot finished on Wed May 29 02:39:34 IST 2019
Soot has run for 0 min. 22 sec.
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 27.355s
[INFO] Finished at: Wed May 29 02:39:34 IST 2019
[INFO] Final Memory: 104M/342M
[INFO] ------------------------------------------------------------------------
